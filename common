#!/usr/bin/env bash

: '
    Common bash code sourced into various scripts.
'

# Constants
DATE_FORMAT='%FT%H:%M:%S.%3NZ'
TIME_ZONE="UTC0"
readonly DATE_FORMAT TIME_ZONE

# Terminal Output
if [ -t 1 ] && [ -z "${NO_COLOR:-}" ]; then
    COLOR_RESET='[0m'; COLOR_RED='[31m'; COLOR_GREEN='[32m'; COLOR_BLUE='[34m'
else
    COLOR_RESET=''; COLOR_RED=''; COLOR_GREEN=''; COLOR_BLUE=''
fi

function sQuote { echo "'${1}'" ; }
function red { echo "${COLOR_RED}${1}${COLOR_RESET}" ; }
function blue { echo "${COLOR_BLUE}${1}${COLOR_RESET}" ; }
function green { echo "${COLOR_GREEN}${1}${COLOR_RESET}" ; }
function logInfo  { echo -e "$(blue "$(TZ=${TIME_ZONE} date +${DATE_FORMAT})")" "$(green "INFO") ${1}" ; }
function logError { echo -e "$(blue "$(TZ=${TIME_ZONE} date +${DATE_FORMAT})")" "$(red   "ERROR") ${1}" ; }

#    Fetches a URL until a given status code is returned. Up to a specified number attempts and with a configurable
#    sleep between each request.
#
#   #1 = the name of the site
#   #2 = the URL to get
#   #3 = the expected success HTTP status code
#   #4 = the maximum number of attempts
#   #5 = the 'sleep' argument to use between fetches
function waitForStatusCode {
  logInfo "Waiting for $(green "${1}") ($(green "${2}")) to return $(blue "${3}")..."
  local statusCode
  # shellcheck disable=SC2034
  for attempt in $(seq 1 "${4}"); do
    statusCode=$(curl --silent --head "${2}" | awk '/^HTTP/{print $2}')
    [[ $statusCode == "$3" ]] && return 0
    sleep "${5}"
  done
  return 1
}

#    Naively formats a URL given: scheme, host, port & path components
#
#   #1 = the scheme
#   #2 = the host
#   #3 = the port
#   #4 = the path
function makeUrl {
  echo "${1}://${2}:${3}${4}"
}
